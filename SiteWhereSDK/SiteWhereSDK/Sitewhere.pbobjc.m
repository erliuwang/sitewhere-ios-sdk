// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sitewhere.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "Sitewhere.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma mark - SitewhereRoot

@implementation SitewhereRoot

@end

#pragma mark - SitewhereRoot_FileDescriptor

static GPBFileDescriptor *SitewhereRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Model

@implementation Model


typedef struct Model__storage_ {
  uint32_t _has_storage_[0];
} Model__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Model class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Model__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Model_Metadata

@implementation Model_Metadata

@dynamic hasName, name;
@dynamic hasValue, value;

typedef struct Model_Metadata__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *value;
} Model_Metadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .number = Model_Metadata_FieldNumber_Name,
        .hasIndex = 0,
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_Metadata__storage_, name),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "value",
        .number = Model_Metadata_FieldNumber_Value,
        .hasIndex = 1,
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_Metadata__storage_, value),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Model_Metadata class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Model_Metadata__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Model_DeviceLocation

@implementation Model_DeviceLocation

@dynamic hasHardwareId, hardwareId;
@dynamic hasLatitude, latitude;
@dynamic hasLongitude, longitude;
@dynamic hasElevation, elevation;
@dynamic hasEventDate, eventDate;
@dynamic metadataArray, metadataArray_Count;

typedef struct Model_DeviceLocation__storage_ {
  uint32_t _has_storage_[1];
  NSString *hardwareId;
  NSMutableArray *metadataArray;
  double latitude;
  double longitude;
  double elevation;
  uint64_t eventDate;
} Model_DeviceLocation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hardwareId",
        .number = Model_DeviceLocation_FieldNumber_HardwareId,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_DeviceLocation__storage_, hardwareId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "latitude",
        .number = Model_DeviceLocation_FieldNumber_Latitude,
        .hasIndex = 1,
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
        .offset = offsetof(Model_DeviceLocation__storage_, latitude),
        .defaultValue.valueDouble = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "longitude",
        .number = Model_DeviceLocation_FieldNumber_Longitude,
        .hasIndex = 2,
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeDouble,
        .offset = offsetof(Model_DeviceLocation__storage_, longitude),
        .defaultValue.valueDouble = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "elevation",
        .number = Model_DeviceLocation_FieldNumber_Elevation,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
        .offset = offsetof(Model_DeviceLocation__storage_, elevation),
        .defaultValue.valueDouble = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "eventDate",
        .number = Model_DeviceLocation_FieldNumber_EventDate,
        .hasIndex = 4,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeFixed64,
        .offset = offsetof(Model_DeviceLocation__storage_, eventDate),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "metadataArray",
        .number = Model_DeviceLocation_FieldNumber_MetadataArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Model_DeviceLocation__storage_, metadataArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Model_Metadata),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\001\n\000\005\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Model_DeviceLocation class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Model_DeviceLocation__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Model_DeviceAlert

@implementation Model_DeviceAlert

@dynamic hasHardwareId, hardwareId;
@dynamic hasAlertType, alertType;
@dynamic hasAlertMessage, alertMessage;
@dynamic hasEventDate, eventDate;
@dynamic metadataArray, metadataArray_Count;

typedef struct Model_DeviceAlert__storage_ {
  uint32_t _has_storage_[1];
  NSString *hardwareId;
  NSString *alertType;
  NSString *alertMessage;
  NSMutableArray *metadataArray;
  uint64_t eventDate;
} Model_DeviceAlert__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hardwareId",
        .number = Model_DeviceAlert_FieldNumber_HardwareId,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_DeviceAlert__storage_, hardwareId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "alertType",
        .number = Model_DeviceAlert_FieldNumber_AlertType,
        .hasIndex = 1,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_DeviceAlert__storage_, alertType),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "alertMessage",
        .number = Model_DeviceAlert_FieldNumber_AlertMessage,
        .hasIndex = 2,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_DeviceAlert__storage_, alertMessage),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "eventDate",
        .number = Model_DeviceAlert_FieldNumber_EventDate,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeFixed64,
        .offset = offsetof(Model_DeviceAlert__storage_, eventDate),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "metadataArray",
        .number = Model_DeviceAlert_FieldNumber_MetadataArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Model_DeviceAlert__storage_, metadataArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Model_Metadata),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\004\001\n\000\002\t\000\003\014\000\004\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Model_DeviceAlert class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Model_DeviceAlert__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Model_Measurement

@implementation Model_Measurement

@dynamic hasMeasurementId, measurementId;
@dynamic hasMeasurementValue, measurementValue;

typedef struct Model_Measurement__storage_ {
  uint32_t _has_storage_[1];
  NSString *measurementId;
  double measurementValue;
} Model_Measurement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "measurementId",
        .number = Model_Measurement_FieldNumber_MeasurementId,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_Measurement__storage_, measurementId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "measurementValue",
        .number = Model_Measurement_FieldNumber_MeasurementValue,
        .hasIndex = 1,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeDouble,
        .offset = offsetof(Model_Measurement__storage_, measurementValue),
        .defaultValue.valueDouble = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\001\r\000\002\020\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Model_Measurement class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Model_Measurement__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Model_DeviceMeasurements

@implementation Model_DeviceMeasurements

@dynamic hasHardwareId, hardwareId;
@dynamic measurementArray, measurementArray_Count;
@dynamic hasEventDate, eventDate;
@dynamic metadataArray, metadataArray_Count;

typedef struct Model_DeviceMeasurements__storage_ {
  uint32_t _has_storage_[1];
  NSString *hardwareId;
  NSMutableArray *measurementArray;
  NSMutableArray *metadataArray;
  uint64_t eventDate;
} Model_DeviceMeasurements__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hardwareId",
        .number = Model_DeviceMeasurements_FieldNumber_HardwareId,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_DeviceMeasurements__storage_, hardwareId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "measurementArray",
        .number = Model_DeviceMeasurements_FieldNumber_MeasurementArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Model_DeviceMeasurements__storage_, measurementArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Model_Measurement),
        .fieldOptions = NULL,
      },
      {
        .name = "eventDate",
        .number = Model_DeviceMeasurements_FieldNumber_EventDate,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeFixed64,
        .offset = offsetof(Model_DeviceMeasurements__storage_, eventDate),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "metadataArray",
        .number = Model_DeviceMeasurements_FieldNumber_MetadataArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Model_DeviceMeasurements__storage_, metadataArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Model_Metadata),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\001\n\000\003\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Model_DeviceMeasurements class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Model_DeviceMeasurements__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Model_DeviceStream

@implementation Model_DeviceStream

@dynamic hasHardwareId, hardwareId;
@dynamic hasStreamId, streamId;
@dynamic hasContentType, contentType;
@dynamic metadataArray, metadataArray_Count;

typedef struct Model_DeviceStream__storage_ {
  uint32_t _has_storage_[1];
  NSString *hardwareId;
  NSString *streamId;
  NSString *contentType;
  NSMutableArray *metadataArray;
} Model_DeviceStream__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hardwareId",
        .number = Model_DeviceStream_FieldNumber_HardwareId,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_DeviceStream__storage_, hardwareId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "streamId",
        .number = Model_DeviceStream_FieldNumber_StreamId,
        .hasIndex = 1,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_DeviceStream__storage_, streamId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "contentType",
        .number = Model_DeviceStream_FieldNumber_ContentType,
        .hasIndex = 2,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_DeviceStream__storage_, contentType),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "metadataArray",
        .number = Model_DeviceStream_FieldNumber_MetadataArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Model_DeviceStream__storage_, metadataArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Model_Metadata),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\003\001\n\000\002\010\000\003\013\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Model_DeviceStream class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Model_DeviceStream__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Model_DeviceStreamData

@implementation Model_DeviceStreamData

@dynamic hasHardwareId, hardwareId;
@dynamic hasStreamId, streamId;
@dynamic hasSequenceNumber, sequenceNumber;
@dynamic hasData_p, data_p;
@dynamic hasEventDate, eventDate;
@dynamic metadataArray, metadataArray_Count;

typedef struct Model_DeviceStreamData__storage_ {
  uint32_t _has_storage_[1];
  NSString *hardwareId;
  NSString *streamId;
  NSData *data_p;
  NSMutableArray *metadataArray;
  uint64_t sequenceNumber;
  uint64_t eventDate;
} Model_DeviceStreamData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hardwareId",
        .number = Model_DeviceStreamData_FieldNumber_HardwareId,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_DeviceStreamData__storage_, hardwareId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "streamId",
        .number = Model_DeviceStreamData_FieldNumber_StreamId,
        .hasIndex = 1,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Model_DeviceStreamData__storage_, streamId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "sequenceNumber",
        .number = Model_DeviceStreamData_FieldNumber_SequenceNumber,
        .hasIndex = 2,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeFixed64,
        .offset = offsetof(Model_DeviceStreamData__storage_, sequenceNumber),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "data_p",
        .number = Model_DeviceStreamData_FieldNumber_Data_p,
        .hasIndex = 3,
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
        .offset = offsetof(Model_DeviceStreamData__storage_, data_p),
        .defaultValue.valueData = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "eventDate",
        .number = Model_DeviceStreamData_FieldNumber_EventDate,
        .hasIndex = 4,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeFixed64,
        .offset = offsetof(Model_DeviceStreamData__storage_, eventDate),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "metadataArray",
        .number = Model_DeviceStreamData_FieldNumber_MetadataArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Model_DeviceStreamData__storage_, metadataArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Model_Metadata),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\004\001\n\000\002\010\000\003\016\000\005\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Model_DeviceStreamData class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Model_DeviceStreamData__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SiteWhere

@implementation SiteWhere


typedef struct SiteWhere__storage_ {
  uint32_t _has_storage_[0];
} SiteWhere__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = SiteWhere_Command_EnumDescriptor },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SiteWhere class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(SiteWhere__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum SiteWhere_Command

GPBEnumDescriptor *SiteWhere_Command_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "SendRegistration", .number = SiteWhere_Command_SendRegistration },
      { .name = "SendAcknowledgement", .number = SiteWhere_Command_SendAcknowledgement },
      { .name = "SendDeviceLocation", .number = SiteWhere_Command_SendDeviceLocation },
      { .name = "SendDeviceAlert", .number = SiteWhere_Command_SendDeviceAlert },
      { .name = "SendDeviceMeasurements", .number = SiteWhere_Command_SendDeviceMeasurements },
      { .name = "SendDeviceStream", .number = SiteWhere_Command_SendDeviceStream },
      { .name = "SendDeviceStreamData", .number = SiteWhere_Command_SendDeviceStreamData },
      { .name = "RequestDeviceStreamData", .number = SiteWhere_Command_RequestDeviceStreamData },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SiteWhere_Command)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:SiteWhere_Command_IsValidValue];
  }
  return descriptor;
}

BOOL SiteWhere_Command_IsValidValue(int32_t value__) {
  switch (value__) {
    case SiteWhere_Command_SendRegistration:
    case SiteWhere_Command_SendAcknowledgement:
    case SiteWhere_Command_SendDeviceLocation:
    case SiteWhere_Command_SendDeviceAlert:
    case SiteWhere_Command_SendDeviceMeasurements:
    case SiteWhere_Command_SendDeviceStream:
    case SiteWhere_Command_SendDeviceStreamData:
    case SiteWhere_Command_RequestDeviceStreamData:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SiteWhere_Header

@implementation SiteWhere_Header

@dynamic hasCommand, command;
@dynamic hasOriginator, originator;

typedef struct SiteWhere_Header__storage_ {
  uint32_t _has_storage_[1];
  SiteWhere_Command command;
  NSString *originator;
} SiteWhere_Header__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "command",
        .number = SiteWhere_Header_FieldNumber_Command,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(SiteWhere_Header__storage_, command),
        .defaultValue.valueEnum = SiteWhere_Command_SendRegistration,
        .dataTypeSpecific.enumDescFunc = SiteWhere_Command_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "originator",
        .number = SiteWhere_Header_FieldNumber_Originator,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(SiteWhere_Header__storage_, originator),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SiteWhere_Header class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(SiteWhere_Header__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SiteWhere_RegisterDevice

@implementation SiteWhere_RegisterDevice

@dynamic hasHardwareId, hardwareId;
@dynamic hasSpecificationToken, specificationToken;
@dynamic metadataArray, metadataArray_Count;
@dynamic hasSiteToken, siteToken;

typedef struct SiteWhere_RegisterDevice__storage_ {
  uint32_t _has_storage_[1];
  NSString *hardwareId;
  NSString *specificationToken;
  NSMutableArray *metadataArray;
  NSString *siteToken;
} SiteWhere_RegisterDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hardwareId",
        .number = SiteWhere_RegisterDevice_FieldNumber_HardwareId,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(SiteWhere_RegisterDevice__storage_, hardwareId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "specificationToken",
        .number = SiteWhere_RegisterDevice_FieldNumber_SpecificationToken,
        .hasIndex = 1,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(SiteWhere_RegisterDevice__storage_, specificationToken),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "metadataArray",
        .number = SiteWhere_RegisterDevice_FieldNumber_MetadataArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(SiteWhere_RegisterDevice__storage_, metadataArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Model_Metadata),
        .fieldOptions = NULL,
      },
      {
        .name = "siteToken",
        .number = SiteWhere_RegisterDevice_FieldNumber_SiteToken,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(SiteWhere_RegisterDevice__storage_, siteToken),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\003\001\n\000\002\022\000\004\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SiteWhere_RegisterDevice class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(SiteWhere_RegisterDevice__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SiteWhere_Acknowledge

@implementation SiteWhere_Acknowledge

@dynamic hasHardwareId, hardwareId;
@dynamic hasMessage, message;

typedef struct SiteWhere_Acknowledge__storage_ {
  uint32_t _has_storage_[1];
  NSString *hardwareId;
  NSString *message;
} SiteWhere_Acknowledge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hardwareId",
        .number = SiteWhere_Acknowledge_FieldNumber_HardwareId,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(SiteWhere_Acknowledge__storage_, hardwareId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "message",
        .number = SiteWhere_Acknowledge_FieldNumber_Message,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(SiteWhere_Acknowledge__storage_, message),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001\n\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SiteWhere_Acknowledge class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(SiteWhere_Acknowledge__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SiteWhere_DeviceStreamDataRequest

@implementation SiteWhere_DeviceStreamDataRequest

@dynamic hasHardwareId, hardwareId;
@dynamic hasStreamId, streamId;
@dynamic hasSequenceNumber, sequenceNumber;

typedef struct SiteWhere_DeviceStreamDataRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *hardwareId;
  NSString *streamId;
  uint64_t sequenceNumber;
} SiteWhere_DeviceStreamDataRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hardwareId",
        .number = SiteWhere_DeviceStreamDataRequest_FieldNumber_HardwareId,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(SiteWhere_DeviceStreamDataRequest__storage_, hardwareId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "streamId",
        .number = SiteWhere_DeviceStreamDataRequest_FieldNumber_StreamId,
        .hasIndex = 1,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(SiteWhere_DeviceStreamDataRequest__storage_, streamId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "sequenceNumber",
        .number = SiteWhere_DeviceStreamDataRequest_FieldNumber_SequenceNumber,
        .hasIndex = 2,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeFixed64,
        .offset = offsetof(SiteWhere_DeviceStreamDataRequest__storage_, sequenceNumber),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\003\001\n\000\002\010\000\003\016\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SiteWhere_DeviceStreamDataRequest class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(SiteWhere_DeviceStreamDataRequest__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Device

@implementation Device


typedef struct Device__storage_ {
  uint32_t _has_storage_[0];
} Device__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = Device_Command_EnumDescriptor },
      { .enumDescriptorFunc = Device_RegistrationAckState_EnumDescriptor },
      { .enumDescriptorFunc = Device_RegistrationAckError_EnumDescriptor },
      { .enumDescriptorFunc = Device_DeviceStreamAckState_EnumDescriptor },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Device class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Device__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum Device_Command

GPBEnumDescriptor *Device_Command_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "AckRegistration", .number = Device_Command_AckRegistration },
      { .name = "AckDeviceStream", .number = Device_Command_AckDeviceStream },
      { .name = "ReceiveDeviceStreamData", .number = Device_Command_ReceiveDeviceStreamData },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Device_Command)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Device_Command_IsValidValue];
  }
  return descriptor;
}

BOOL Device_Command_IsValidValue(int32_t value__) {
  switch (value__) {
    case Device_Command_AckRegistration:
    case Device_Command_AckDeviceStream:
    case Device_Command_ReceiveDeviceStreamData:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Device_RegistrationAckState

GPBEnumDescriptor *Device_RegistrationAckState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "NewRegistration", .number = Device_RegistrationAckState_NewRegistration },
      { .name = "AlreadyRegistered", .number = Device_RegistrationAckState_AlreadyRegistered },
      { .name = "RegistrationError", .number = Device_RegistrationAckState_RegistrationError },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Device_RegistrationAckState)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Device_RegistrationAckState_IsValidValue];
  }
  return descriptor;
}

BOOL Device_RegistrationAckState_IsValidValue(int32_t value__) {
  switch (value__) {
    case Device_RegistrationAckState_NewRegistration:
    case Device_RegistrationAckState_AlreadyRegistered:
    case Device_RegistrationAckState_RegistrationError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Device_RegistrationAckError

GPBEnumDescriptor *Device_RegistrationAckError_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvalidSpecification", .number = Device_RegistrationAckError_InvalidSpecification },
      { .name = "SiteTokenRequired", .number = Device_RegistrationAckError_SiteTokenRequired },
      { .name = "NewDevicesNotAllowed", .number = Device_RegistrationAckError_NewDevicesNotAllowed },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Device_RegistrationAckError)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Device_RegistrationAckError_IsValidValue];
  }
  return descriptor;
}

BOOL Device_RegistrationAckError_IsValidValue(int32_t value__) {
  switch (value__) {
    case Device_RegistrationAckError_InvalidSpecification:
    case Device_RegistrationAckError_SiteTokenRequired:
    case Device_RegistrationAckError_NewDevicesNotAllowed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Device_DeviceStreamAckState

GPBEnumDescriptor *Device_DeviceStreamAckState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "StreamCreated", .number = Device_DeviceStreamAckState_StreamCreated },
      { .name = "StreamExists", .number = Device_DeviceStreamAckState_StreamExists },
      { .name = "StreamFailed", .number = Device_DeviceStreamAckState_StreamFailed },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Device_DeviceStreamAckState)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Device_DeviceStreamAckState_IsValidValue];
  }
  return descriptor;
}

BOOL Device_DeviceStreamAckState_IsValidValue(int32_t value__) {
  switch (value__) {
    case Device_DeviceStreamAckState_StreamCreated:
    case Device_DeviceStreamAckState_StreamExists:
    case Device_DeviceStreamAckState_StreamFailed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Device_Header

@implementation Device_Header

@dynamic hasCommand, command;
@dynamic hasOriginator, originator;
@dynamic hasNestedPath, nestedPath;
@dynamic hasNestedSpec, nestedSpec;

typedef struct Device_Header__storage_ {
  uint32_t _has_storage_[1];
  Device_Command command;
  NSString *originator;
  NSString *nestedPath;
  NSString *nestedSpec;
} Device_Header__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "command",
        .number = Device_Header_FieldNumber_Command,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Device_Header__storage_, command),
        .defaultValue.valueEnum = Device_Command_AckRegistration,
        .dataTypeSpecific.enumDescFunc = Device_Command_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "originator",
        .number = Device_Header_FieldNumber_Originator,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Device_Header__storage_, originator),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "nestedPath",
        .number = Device_Header_FieldNumber_NestedPath,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Device_Header__storage_, nestedPath),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "nestedSpec",
        .number = Device_Header_FieldNumber_NestedSpec,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Device_Header__storage_, nestedSpec),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\003\n\000\004\n\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Device_Header class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Device_Header__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Device_RegistrationAck

@implementation Device_RegistrationAck

@dynamic hasState, state;
@dynamic hasErrorType, errorType;
@dynamic hasErrorMessage, errorMessage;

typedef struct Device_RegistrationAck__storage_ {
  uint32_t _has_storage_[1];
  Device_RegistrationAckState state;
  Device_RegistrationAckError errorType;
  NSString *errorMessage;
} Device_RegistrationAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .number = Device_RegistrationAck_FieldNumber_State,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Device_RegistrationAck__storage_, state),
        .defaultValue.valueEnum = Device_RegistrationAckState_NewRegistration,
        .dataTypeSpecific.enumDescFunc = Device_RegistrationAckState_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "errorType",
        .number = Device_RegistrationAck_FieldNumber_ErrorType,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Device_RegistrationAck__storage_, errorType),
        .defaultValue.valueEnum = Device_RegistrationAckError_InvalidSpecification,
        .dataTypeSpecific.enumDescFunc = Device_RegistrationAckError_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "errorMessage",
        .number = Device_RegistrationAck_FieldNumber_ErrorMessage,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Device_RegistrationAck__storage_, errorMessage),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\002\t\000\003\014\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Device_RegistrationAck class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Device_RegistrationAck__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Device_DeviceStreamAck

@implementation Device_DeviceStreamAck

@dynamic hasStreamId, streamId;
@dynamic hasState, state;

typedef struct Device_DeviceStreamAck__storage_ {
  uint32_t _has_storage_[1];
  Device_DeviceStreamAckState state;
  NSString *streamId;
} Device_DeviceStreamAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "streamId",
        .number = Device_DeviceStreamAck_FieldNumber_StreamId,
        .hasIndex = 0,
        .flags = GPBFieldRequired | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Device_DeviceStreamAck__storage_, streamId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "state",
        .number = Device_DeviceStreamAck_FieldNumber_State,
        .hasIndex = 1,
        .flags = GPBFieldRequired | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Device_DeviceStreamAck__storage_, state),
        .defaultValue.valueEnum = Device_DeviceStreamAckState_StreamCreated,
        .dataTypeSpecific.enumDescFunc = Device_DeviceStreamAckState_EnumDescriptor,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001\010\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Device_DeviceStreamAck class]
                                     rootClass:[SitewhereRoot class]
                                          file:SitewhereRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Device_DeviceStreamAck__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


// @@protoc_insertion_point(global_scope)
